# Latent mixture model that can test our three hypotheses
#H0: Null hypothesis that riskaversion is NOT dynamic specific. Riskaversion parameter free to vary.
#H1: Allowing for different riskpreferences across dynamics - no restrictions.
#H2: Allowing for different riskpreferences across dynamics - riskpreference in multiplicative is greater than in additive
#H3: Riskpreferences approcimate growth-optimality, ie. eta_add approx 0 and eta_mul approx 1

model{

##LIKELIHOOD
for (i in 1:nAgents){
for (g in 1:nGambles){
for (t in 1:nTrials){

    #-----------H0-----------
    u_0[i,c,t]      = ( pow(w[i,c,t] , ( 1 - eta_0[i] ) ) -1 ) / ( 1- eta_0[i] )  #transforms wealth into utility

    u1_0[i,c,t]     = ( pow(w1_1[i,c,t], (1 - eta_0[i])) -1 ) / (1 - eta_0[i])  #transform wealth update for upper left into utility
    u2_0[i,c,t]     = ( pow(w1_2[i,c,t], (1 - eta_0[i])) -1 ) / (1 - eta_0[i])
    u3_0[i,c,t]     = ( pow(w2_1[i,c,t], (1 - eta_0[i])) -1 ) / (1 - eta_0[i])
    u4_0[i,c,t]     = ( pow(w2_2[i,c,t], (1 - eta_0[i])) -1 ) / (1 - eta_0[i])

    du1_0[i,c,t]    = u1_0[i,c,t] - u_0[i,c,t]  #computes change in utility
    du2_0[i,c,t]    = u2_0[i,c,t] - u_0[i,c,t]
    du3_0[i,c,t]    = u3_0[i,c,t] - u_0[i,c,t]
    du4_0[i,c,t]    = u4_0[i,c,t] - u_0[i,c,t]

    edug1_0[i,c,t]  = ( du1_0[i,c,t] + du2_0[i,c,t] ) / 2  #computes expected change in utiluty for each gamble
    edug2_0[i,c,t]  = ( du3_0[i,c,t] + du4_0[i,c,t] ) / 2

    deu_0[i,c,t]    = edug1_0[i,c,t] - edug2_0[i,c,t]                   #computes difference in expected change in utility
    sdeu_0[i,c,t]   = -1 * beta_0[i,c] * deu_0[i,c,t]                   #scaled by sensitivity parameter
    tmp_0[i,c,t]    = ( 1 ) / ( 1 + (exp(sdeu_0[i,c,t]) ) )           #choice probability
    theta[i,c,t,1]  = max( 0.000001 , min(0.999999 , tmp_0[i,c,t]) )  #ensure 0 < cp < 1

    #-----------H1-----------
    u_1[i,c,t]      = ( pow(w[i,c,t] , ( 1 - eta_1[i,c] ) ) -1 ) / ( 1- eta_1[i,c] )  #transforms wealth into utility

    u1_1[i,c,t]     = ( pow(w1_1[i,c,t], (1 - eta_1[i,c])) -1 ) / (1 - eta_1[i,c])  #transform wealth update for upper left into utility
    u2_1[i,c,t]     = ( pow(w1_2[i,c,t], (1 - eta_1[i,c])) -1 ) / (1 - eta_1[i,c])
    u3_1[i,c,t]     = ( pow(w2_1[i,c,t], (1 - eta_1[i,c])) -1 ) / (1 - eta_1[i,c])
    u4_1[i,c,t]     = ( pow(w2_2[i,c,t], (1 - eta_1[i,c])) -1 ) / (1 - eta_1[i,c])

    du1_1[i,c,t]    = u1_1[i,c,t] - u_1[i,c,t]  #computes change in utility
    du2_1[i,c,t]    = u2_1[i,c,t] - u_1[i,c,t]
    du3_1[i,c,t]    = u3_1[i,c,t] - u_1[i,c,t]
    du4_1[i,c,t]    = u4_1[i,c,t] - u_1[i,c,t]

    edug1_1[i,c,t]  = ( du1_1[i,c,t] + du2_1[i,c,t] ) / 2  #computes expected change in utiluty for each gamble
    edug2_1[i,c,t]  = ( du3_1[i,c,t] + du4_1[i,c,t] ) / 2

    deu_1[i,c,t]    = edug1_1[i,c,t] - edug2_1[i,c,t]                   #computes difference in expected change in utility
    sdeu_1[i,c,t]   = -1 * beta_1[i,c] * deu_1[i,c,t]                   #scaled by sensitivity parameter
    tmp_1[i,c,t]    = ( 1 ) / ( 1 + (exp(sdeu_1[i,c,t]) ) )           #choice probability
    theta[i,c,t,2]  = max( 0.000001 , min(0.999999 , tmp_1[i,c,t]) )  #ensure 0 < cp < 1

    #-----------H2-----------
    u_2[i,c,t]      = ( pow(w[i,c,t] , ( 1 - eta_2[i,c] ) ) -1 ) / ( 1- eta_2[i,c] )  #transforms wealth into utility

    u1_2[i,c,t]     = ( pow(w1_2[i,c,t], (1 - eta_2[i,c])) -1 ) / (1 - eta_2[i,c])  #transform wealth update for upper left into utility
    u2_2[i,c,t]     = ( pow(w1_2[i,c,t], (1 - eta_2[i,c])) -1 ) / (1 - eta_2[i,c])
    u3_2[i,c,t]     = ( pow(w2_2[i,c,t], (1 - eta_2[i,c])) -1 ) / (1 - eta_2[i,c])
    u4_2[i,c,t]     = ( pow(w2_2[i,c,t], (1 - eta_2[i,c])) -1 ) / (1 - eta_2[i,c])

    du1_2[i,c,t]    = u1_2[i,c,t] - u_2[i,c,t]  #computes change in utility
    du2_2[i,c,t]    = u2_2[i,c,t] - u_2[i,c,t]
    du3_2[i,c,t]    = u3_2[i,c,t] - u_2[i,c,t]
    du4_2[i,c,t]    = u4_2[i,c,t] - u_2[i,c,t]

    edug1_2[i,c,t]  = ( du1_2[i,c,t] + du2_2[i,c,t] ) / 2  #computes expected change in utiluty for each gamble
    edug2_2[i,c,t]  = ( du3_2[i,c,t] + du4_2[i,c,t] ) / 2

    deu_2[i,c,t]    = edug1_2[i,c,t] - edug2_2[i,c,t]                   #computes difference in expected change in utility
    sdeu_2[i,c,t]   = -1 * beta_2[i,c] * deu_2[i,c,t]                   #scaled by sensitivity parameter
    tmp_2[i,c,t]    = ( 1 ) / ( 1 + (exp(sdeu_2[i,c,t]) ) )           #choice probability
    theta[i,c,t,3]  = max( 0.000001 , min(0.999999 , tmp_2[i,c,t]) )  #ensure 0 < cp < 1

    #-----------H3-----------
    u1_3[i,c,t]     = ( pow(w1_3[i,c,t], (1 - eta_3[i,c])) -1 ) / (1 - eta_3[i,c])  #transform wealth update for upper left into utility
    u2_3[i,c,t]     = ( pow(w1_3[i,c,t], (1 - eta_3[i,c])) -1 ) / (1 - eta_3[i,c])
    u3_3[i,c,t]     = ( pow(w2_3[i,c,t], (1 - eta_3[i,c])) -1 ) / (1 - eta_3[i,c])
    u4_3[i,c,t]     = ( pow(w2_3[i,c,t], (1 - eta_3[i,c])) -1 ) / (1 - eta_3[i,c])

    du1_3[i,c,t]    = u1_3[i,c,t] - u_3[i,c,t]  #computes change in utility
    du2_3[i,c,t]    = u2_3[i,c,t] - u_3[i,c,t]
    du3_3[i,c,t]    = u3_3[i,c,t] - u_3[i,c,t]
    du4_3[i,c,t]    = u4_3[i,c,t] - u_3[i,c,t]

    edug1_3[i,c,t]  = ( du1_3[i,c,t] + du2_3[i,c,t] ) / 2  #computes expected change in utiluty for each gamble
    edug2_3[i,c,t]  = ( du3_3[i,c,t] + du4_3[i,c,t] ) / 2

    deu_3[i,c,t]    = edug1_3[i,c,t] - edug2_3[i,c,t]                   #computes difference in expected change in utility
    sdeu_3[i,c,t]   = -1 * beta_3[i,c] * deu_3[i,c,t]                   #scaled by sensitivity parameter
    tmp_3[i,c,t]    = ( 1 ) / ( 1 + (exp(sdeu_3[i,c,t]) ) )           #choice probability
    theta[i,c,t,4]  = max( 0.000001 , min(0.999999 , tmp_3[i,c,t]) )  #ensure 0 < cp < 1

    #-----------H3-----------
    u1_3[i,c,t]     = ( pow(w1_3[i,c,t], (1 - eta_3[i,c])) -1 ) / (1 - eta_3[i,c])  #transform wealth update for upper left into utility
    u2_3[i,c,t]     = ( pow(w1_3[i,c,t], (1 - eta_3[i,c])) -1 ) / (1 - eta_3[i,c])
    u3_3[i,c,t]     = ( pow(w2_3[i,c,t], (1 - eta_3[i,c])) -1 ) / (1 - eta_3[i,c])
    u4_3[i,c,t]     = ( pow(w2_3[i,c,t], (1 - eta_3[i,c])) -1 ) / (1 - eta_3[i,c])

    du1_3[i,c,t]    = u1_3[i,c,t] - u_3[i,c,t]  #computes change in utility
    du2_3[i,c,t]    = u2_3[i,c,t] - u_3[i,c,t]
    du3_3[i,c,t]    = u3_3[i,c,t] - u_3[i,c,t]
    du4_3[i,c,t]    = u4_3[i,c,t] - u_3[i,c,t]

    edug1_3[i,c,t]  = ( du1_3[i,c,t] + du2_3[i,c,t] ) / 2  #computes expected change in utiluty for each gamble edug2_3[i,c,t]  = ( du3_3[i,c,t] + du4_3[i,c,t] ) / 2
    theta[i,c,t,4]  = max( 0.000001 , min(0.999999 , tmp_3[i,c,t]) )  #ensure 0 < cp < 1

    #-----------Choice-----------
    y[i,g,t]           	~ dbern(theta[i,g,t,z[i]])

}# end of trials
}# end of gambles
}# end of agents

##PRIORS

#indicator variables
#the model indicator variable z can take on any value from 1:n, and is subject to two stochastic processes, to prevent getting stuck
#the n values map onto just nModels models, and is simply a means of obtaining parameter expansion for the model indication
for (i in 1:nAgents){
	px_z1[i]    ~ dcat(pz[])                                 #parameter expansion variable for z, takes on integers 1:n with equal probability
	px_z2[i]    ~ dcat(pz[])                                 #parameter expansion variable for z, takes on integers 1:n with equal probability
	delta_z1[i] = px_z2[i]-1                                 #parameter expansion variable for z, takes on integers 0:n-1 with equal probability
	sum_z[i]    = px_z1[i]+delta_z1[i]                       #sum takes on integers 1:2*n -1 with equal probability
	z[i]        = (sum_z[i] - (4 * trunc(sum_z[i]/4))) + 1   #modulo n, adding 1 to return to values 1 to nModels
}#end of agents

#submodels
for (i in 1:nSubjects){
    for (c in 1:nDynamics){
        #H0
        beta_0[i,c]     = exp(log_beta_0[i,c])
        log_beta_0[i,c] ~ dnorm(mu_log_beta_0[c],tau_log_beta_0[c])

        #H1
        eta_1[i,c]      ~ dnorm(mu_eta_1[c],tau_eta_1)
        beta_1[i,c]     = exp(log_beta_1[i,c])
        log_beta_1[i,c] ~ dnorm(mu_log_beta_1[c],tau_log_beta_0[c])

        #H2
        eta_2[i,c]      ~ dnorm(mu_eta_2[c],tau_eta_2)
        beta_2[i,c]     = exp(log_beta_2[i,c])
        log_beta_2[i,c] ~ dnorm(mu_log_beta_2[c],tau_log_beta_2[c])

        #H3
        eta_3[i,c]      ~ dnorm(mu_eta_3[c],tau_eta_3)
        beta_3[i,c]     = exp(log_beta_3[i,c])
        log_beta_3[i,c] ~ dnorm(mu_log_beta_3[c],tau_log_beta_3[c])
    }#end dynamics

    #-----------H0-----------
    eta_0 ~ dnorm(mu_eta_0,tau_eta_0)
}#end of subjects

##HYPERPRIORS

for (c in 1:nDynamics){
    #-----------H0-----------
    mu_log_beta_0[c]      ~ dunif(muLogBetaL,muLogBetaU)  		#prior on mean of dist. of log beta_0
    tau_log_beta_0[c]     = pow(sigma_log_beta_0[c],-2)   		#prior on precision of dist. of log beta_0
    sigma_log_beta_0[c]   ~ dunif(sigmaLogBetaL,sigmaLogBetaU)	#prior on std of dist. of log beta_0

    #-----------H1-----------
    mu_log_eta_1[c]      ~ dunif(muLogElaL,muLogEtaU)         	#prior on mean of dist. of log eta_1
    mu_log_beta_1[c]     ~ dunif(muLogBetaL,muLogBetaU)  		#prior on mean of dist. of log beta_1
    tau_log_beta_1[c]    = pow(sigma_log_beta_1[c],-2)   		#prior on precision of dist. of log beta_1
    sigma_log_beta_1[c]  ~ dunif(sigmaLogBetaL,sigmaLogBetaU)	#prior on std of dist. of log beta_1

    #-----------H2-----------
    mu_log_eta_2[c]      ~ dunif(muLogElaL,muLogEtaU)         	#prior on mean of dist. of log eta_2
    mu_log_beta_2[c]     ~ dunif(muLogBetaL,muLogBetaU)  		#prior on mean of dist. of log beta_2
    tau_log_beta_2[c]    = pow(sigma_log_beta_2[c],-2)   		#prior on precision of dist. of log beta_2
    sigma_log_beta_0[c]  ~ dunif(sigmaLogBetaL,sigmaLogBetaU)	#prior on std of dist. of log beta_2

    #-----------H3-----------
    mu_eta_3[c]          = selectEtaGO[c]
    mu_log_beta_3[c]     ~ dunif(muLogBetaL,muLogBetaU)  		#prior on mean of dist. of log beta_3
    tau_log_beta_3[c]    = pow(sigma_log_beta_3[c],-2)   		#prior on precision of dist. of log beta_3
    sigma_log_beta_3[c]  ~ dunif(sigmaLogBetaL,sigmaLogBetaU)	#prior on std of dist. of log beta_3
}

#-----------H0-----------
mu_eta_0      ~ dunif(muLogElaL,muLogEtaU)         	#prior on mean of dist. of log eta_0
tau_eta_0     = pow(sigma_log_eta_0,-2)          	#prior on precision of dist. of log eta_0
sigma_eta_0   ~ dunif(sigmaLogEtaL,sigmaLogEtaU)   	#prior on std of dist. of log eta_0

#-----------H1-----------
tau_eta_1     = pow(sigma_log_eta_1,-2)          	#prior on precision of dist. of log eta_1
sigma_eta_1   ~ dunif(sigmaLogEtaL,sigmaLogEtaU)   	#prior on std of dist. of log eta_1

#-----------H2-----------
tau_eta_2     = pow(sigma_log_eta_2,-2)          	#prior on precision of dist. of log eta_2
sigma_eta_2   ~ dunif(sigmaLogEtaL,sigmaLogEtaU)   	#prior on std of dist. of log eta_2

#-----------H3-----------
tau_eta_3     = pow(sigma_log_eta_3,-2)          	#prior on precision of dist. of log eta_3
sigma_eta_3   ~ dunif(sigmaLogEtaL,sigmaLogEtaU)   	#prior on std of dist. of log eta_3

#condition specific etas
selectEtaTw[1] = 0       #sets eta to zero (linear utility) for additive session
selectEtaTw[2] = 1.00001 #sets eta to ~1 (log utility) for multiplicative session, 1.00001 prevents dividing by 0, but still arbitrarily close to a logarithm
}