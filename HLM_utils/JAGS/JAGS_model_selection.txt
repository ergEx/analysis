# Latent mixture model that can test our hypothesis
#H0: Null hypothesis that riskaversion is NOT dynamic specific. Riskaversion parameter free to vary.
#H1: Alternative hypothesis that riskaversion in multiplicative dynamic is greater than in additive dynamic. Riskaversion parameters free to vary.

model{

##LIKELIHOOD
for (i in 1:nSubjects){
for (c in 1:nConditions){
for (t in 1:nTrials){

    #-----------H0-----------
    u_0[i,c,t]      = ( pow(w[i,c,t] , ( 1 - eta_0[i] ) ) -1 ) / ( 1- eta_0[i] )  #transforms wealth into utility

    u1_0[i,c,t]     = ( pow(w1_1[i,c,t], (1 - eta_0[i])) -1 ) / (1 - eta_0[i])  #transform wealth update for upper left into utility
    u2_0[i,c,t]     = ( pow(w1_2[i,c,t], (1 - eta_0[i])) -1 ) / (1 - eta_0[i])
    u3_0[i,c,t]     = ( pow(w2_1[i,c,t], (1 - eta_0[i])) -1 ) / (1 - eta_0[i])
    u4_0[i,c,t]     = ( pow(w2_2[i,c,t], (1 - eta_0[i])) -1 ) / (1 - eta_0[i])

    du1_0[i,c,t]    = u1_0[i,c,t] - u_0[i,c,t]  #computes change in utility
    du2_0[i,c,t]    = u2_0[i,c,t] - u_0[i,c,t]
    du3_0[i,c,t]    = u3_0[i,c,t] - u_0[i,c,t]
    du4_0[i,c,t]    = u4_0[i,c,t] - u_0[i,c,t]

    edug1_0[i,c,t]  = ( du1_0[i,c,t] + du2_0[i,c,t] ) / 2  #computes expected change in utiluty for each gamble
    edug2_0[i,c,t]  = ( du3_0[i,c,t] + du4_0[i,c,t] ) / 2

    deu_0[i,c,t]    = edug1_0[i,c,t] - edug2_0[i,c,t]                   #computes difference in expected change in utility
    sdeu_0[i,c,t]   = -1 * beta_0[i,c] * deu_0[i,c,t]                   #scaled by sensitivity parameter
    tmp_0[i,c,t]    = ( 1 ) / ( 1 + (exp(sdeu_0[i,c,t]) ) )           #choice probability
    theta[i,c,t,1]  = max( 0.000001 , min(0.999999 , tmp_0[i,c,t]) )  #ensure 0 < cp < 1

    #-----------H1-----------
    u_1[i,c,t]      = ( pow(w[i,c,t] , ( 1 - (eta_1[i]+etaM[i,c]) ) ) -1 ) / ( 1- (eta_1[i]=etaM[i,c]) )  #transforms wealth into utility

    u1_1[i,c,t]     = ( pow(w1_1[i,c,t], (1 - (eta_1[i]+etaM[i,c]))) -1 ) / (1 - (eta_1[i]+etaM[i,c]))  #transform wealth update for upper left into utility
    u2_1[i,c,t]     = ( pow(w1_2[i,c,t], (1 - (eta_1[i]+etaM[i,c]))) -1 ) / (1 - (eta_1[i]+etaM[i,c]))
    u3_1[i,c,t]     = ( pow(w2_1[i,c,t], (1 - (eta_1[i]+etaM[i,c]))) -1 ) / (1 - (eta_1[i]+etaM[i,c]))
    u4_1[i,c,t]     = ( pow(w2_2[i,c,t], (1 - (eta_1[i]+etaM[i,c]))) -1 ) / (1 - (eta_1[i]+etaM[i,c]))

    du1_1[i,c,t]    = u1_1[i,c,t] - u_1[i,c,t]  #computes change in utility
    du2_1[i,c,t]    = u2_1[i,c,t] - u_1[i,c,t]
    du3_1[i,c,t]    = u3_1[i,c,t] - u_1[i,c,t]
    du4_1[i,c,t]    = u4_1[i,c,t] - u_1[i,c,t]

    edug1_1[i,c,t]  = ( du1_1[i,c,t] + du2_1[i,c,t] ) / 2  #computes expected change in utiluty for each gamble
    edug2_1[i,c,t]  = ( du3_1[i,c,t] + du4_1[i,c,t] ) / 2

    deu_1[i,c,t]    = edug1_1[i,c,t] - edug2_1[i,c,t]                 #computes difference in expected change in utility
    sdeu_1[i,c,t]   = -1 * beta_1[i,c] * deu_1[i,c,t]                 #scaled by sensitivity parameter
    tmp_1[i,c,t]    = ( 1 ) / ( 1 + (exp(sdeu_1[i,c,t]) ) )           #choice probability
    theta[i,c,t,2]  = max( 0.000001 , min(0.999999 , tmp_1[i,c,t]) )  #ensure 0 < cp < 1

    #-----------Choice-----------
    y[i,g,t]           	~ dbern(theta[i,g,t,z[i]])

}# end of trials
}# end of conditions
}# end of subjects

##PRIORS
#indicator variables
#the model indicator variable z can take on any value from 1:n, and is subject to two stochastic processes, to prevent getting stuck
#the n values map onto just nModels models, and is simply a means of obtaining parameter expansion for the model indication

for (i in 1:nSubjects){
	px_z1[i]    ~ dcat(pz[])                                 #parameter expansion variable for z, takes on integers 1:n with equal probability
	px_z2[i]    ~ dcat(pz[])                                 #parameter expansion variable for z, takes on integers 1:n with equal probability
	delta_z1[i] = px_z2[i]-1                                 #parameter expansion variable for z, takes on integers 0:n-1 with equal probability
	sum_z[i]    = px_z1[i]+delta_z1[i]                       #sum takes on integers 1:2*n -1 with equal probability
	z[i]        = (sum_z[i] - (2 * trunc(sum_z[i]/2))) + 1   #modulo n, adding 1 to return to values 1 to nModels
}#end subjects

#submodels
for (i in 1:nSubjects){
    #-----------H0-----------
    eta_0 ~ dnorm(mu_eta_0,tau_eta_0)

    #-----------H1-----------
    eta_1 ~ dnorm(mu_eta_1,tau_eta_1)
    etaM_1[i,0]     = 0
    etaM_1[i,1]     = exp(log_etaM_1[i])
    log_etaM_1[i] ~ dnorm(mu_log_etaM_1,tau_log_etaM_0)

    #Condition specific parameters
    for (c in 1:nConditions){
        #-----------H0-----------
        beta_0[i,c]     = exp(log_beta_0[i,c])
        log_beta_0[i,c] ~ dnorm(mu_log_beta_0[c],tau_log_beta_0[c])

        #-----------H1-----------
        beta_1[i,c]     = exp(log_beta_1[i,c])
        log_beta_1[i,c] ~ dnorm(mu_log_beta_1[c],tau_log_beta_0[c])

    }#end conditions
}#end subjects

##HYPERPRIORS
#-----------H0-----------
mu_eta_0      ~ dunif(muLogElaL,muLogEtaU)         	#prior on mean of dist. of log eta_0
tau_eta_0     = pow(sigma_log_eta_0,-2)          	#prior on precision of dist. of log eta_0
sigma_eta_0   ~ dunif(sigmaLogEtaL,sigmaLogEtaU)   	#prior on std of dist. of log eta_0

#-----------H1-----------
mu_eta_1      ~ dunif(muLogElaL,muLogEtaU)         	#prior on mean of dist. of log eta_1
tau_eta_1     = pow(sigma_log_eta_1,-2)          	#prior on precision of dist. of log eta_1
sigma_eta_1   ~ dunif(sigmaLogEtaL,sigmaLogEtaU)   	#prior on std of dist. of log eta_1

mu_etaM_1      ~ dunif(muLogEtaML,muLogEtaMU)         	#prior on mean of dist. of log etaM_1
tau_etaM_1     = pow(sigma_log_etaM_1,-2)          	#prior on precision of dist. of log etaM_1
sigma_etaM_1   ~ dunif(sigmaLogEtaML,sigmaLogEtaMU)   	#prior on std of dist. of log etaM_1

#condition specific parameters
for (c in 1:nConditions){
    #-----------H0-----------
    mu_log_beta_0[c]      ~ dunif(muLogBetaL,muLogBetaU)  		#prior on mean of dist. of log beta_0
    tau_log_beta_0[c]     = pow(sigma_log_beta_0[c],-2)   		#prior on precision of dist. of log beta_0
    sigma_log_beta_0[c]   ~ dunif(sigmaLogBetaL,sigmaLogBetaU)	#prior on std of dist. of log beta_0

    #-----------H1-----------
    mu_log_beta_1[c]     ~ dunif(muLogBetaL,muLogBetaU)  		#prior on mean of dist. of log beta_1
    tau_log_beta_1[c]    = pow(sigma_log_beta_1[c],-2)   		#prior on precision of dist. of log beta_1
    sigma_log_beta_1[c]  ~ dunif(sigmaLogBetaL,sigmaLogBetaU)	#prior on std of dist. of log beta_1
}#end conditions


}#end model