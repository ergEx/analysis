# Which is best model for each subject out of the following strong models:
#
# Dynamic independent (eta free to vary, but equal across dynamics)
# Dynamic Dependent (eta free to vary, delta_eta represents change from Additive to Multiplicative and must be positive)
#
# Note that the model indicator variable z, is parameter expanded to take on 8 different values rather than 2. This
# allows better convergence. It allows four different values of the indicator variable to map to each model,
# such that a z of 1,3,5,7 maps to the dynamic independent and 2,4,6,8 map to dynamic dependent.

model{

##LIKELIHOOD

for (i in 1:nSubjects){
oneminEtaNoDyn[i] = 1 - etaNoDyn[i]                                                         #1 minus eta term in dynamic independent
for (c in 1:nConditions){
oneminEtaDyn[i,c] = 1 - (etaDyn[i] + delta_eta[i,c])                                        #1 minus eta term in dynamic dependent
for (t in 1:nTrials){
  #Wealth updates
    wLU[i,c,t]    = w[i,c,t] + dwLU[i,c,t]                                                   #wealth if outcome Left Upper
    wLL[i,c,t]    = w[i,c,t] + dwLL[i,c,t]                                                   #wealth if outcome Left Lower
    wRU[i,c,t]    = w[i,c,t] + dwRU[i,c,t]                                                   #wealth if outcome Right Upper
    wRL[i,c,t]    = w[i,c,t] + dwRL[i,c,t]                                                   #wealth if outcome Right Lower
    wLUp[i,c,t] = ifelse(wLU[i,c,t] > 0, wLU[i,c,t], 1)                                      #replacing if negative (doesn't matter cause choice is deleted in input)
    wLLp[i,c,t] = ifelse(wLL[i,c,t] > 0, wLL[i,c,t], 1)                                      #replacing if negative (doesn't matter cause choice is deleted in input)
    wRUp[i,c,t] = ifelse(wRU[i,c,t] > 0, wRU[i,c,t], 1)                                      #replacing if negative (doesn't matter cause choice is deleted in input)
    wRLp[i,c,t] = ifelse(wRL[i,c,t] > 0, wRL[i,c,t], 1)                                      #replacing if negative (doesn't matter cause choice is deleted in input)
    wp[i,c,t]   = ifelse(w[i,c,t] > 0, w[i,c,t], 1)                                          #replacing if negative (doesn't matter cause choice is deleted in input)

#Dynamic independent submodel
    uNoDyn[i,c,t]      = (pow(wp[i,c,t],oneminEtaNoDyn[i]) - 1) / oneminEtaNoDyn[i]          #utility of wealth prior to trial
    uLUNoDyn[i,c,t]    = (pow(wLUp[i,c,t],oneminEtaNoDyn[i]) - 1) / oneminEtaNoDyn[i]        #transforms wealth into utility
    uLLNoDyn[i,c,t]    = (pow(wLLp[i,c,t],oneminEtaNoDyn[i]) - 1) / oneminEtaNoDyn[i]        #transforms wealth into utility
    uRUNoDyn[i,c,t]    = (pow(wRUp[i,c,t],oneminEtaNoDyn[i]) - 1) / oneminEtaNoDyn[i]        #transforms wealth into utility
    uRLNoDyn[i,c,t]    = (pow(wRLp[i,c,t],oneminEtaNoDyn[i]) - 1) / oneminEtaNoDyn[i]        #transforms wealth into utility
    duLUNoDyn[i,c,t]   = uLUNoDyn[i,c,t] - uNoDyn[i,c,t]                                          #delta utility of wealth outcome Left Upper
    duLLNoDyn[i,c,t]   = uLLNoDyn[i,c,t] - uNoDyn[i,c,t]                                          #delta utility of wealth outcome Left Lower
    duRUNoDyn[i,c,t]   = uRUNoDyn[i,c,t] - uNoDyn[i,c,t]                                          #delta utility of wealth outcome Right Upper
    duRLNoDyn[i,c,t]   = uRLNoDyn[i,c,t] - uNoDyn[i,c,t]                                          #delta utility of wealth outcome right Lower
    eduLNoDyn[i,c,t]   = (duLUNoDyn[i,c,t] + duLLNoDyn[i,c,t]) / 2                           #expected change in utility for Left gamble
    eduRNoDyn[i,c,t]   = (duRUNoDyn[i,c,t] + duRLNoDyn[i,c,t]) / 2                           #expected change in utility for Right gamble
    deuNoDyn[i,c,t]    = eduLNoDyn[i,c,t] - eduRNoDyn[i,c,t]                                 #computes difference in expected change in utility
    sdeuNoDyn[i,c,t]   = -1 * betaNoDyn[i,c] * deuNoDyn[i,c,t]                               #scaled by sensitivity parameter
    cpNoDyn[i,c,t]     = 1 / (1 + (exp(sdeuNoDyn[i,c,t])))                                   #choice probability
    theta[i,c,t,1]     = max( 0.000001 , min(0.999999 , cpNoDyn[i,c,t]) )                         #ensure 0 < cp < 1
    theta[i,c,t,3]     = max( 0.000001 , min(0.999999 , cpNoDyn[i,c,t]) )                         #ensure 0 < cp < 1
    theta[i,c,t,5]     = max( 0.000001 , min(0.999999 , cpNoDyn[i,c,t]) )                         #ensure 0 < cp < 1
    theta[i,c,t,7]     = max( 0.000001 , min(0.999999 , cpNoDyn[i,c,t]) )                         #ensure 0 < cp < 1

#Dynamic dependent submodel
    uDyn[i,c,t]      = (pow(wp[i,c,t],oneminEtaDyn[i,c]) - 1) / oneminEtaDyn[i,c]          #utility of wealth prior to trial
    uLUDyn[i,c,t]    = (pow(wLUp[i,c,t],oneminEtaDyn[i,c]) - 1) / oneminEtaDyn[i,c]        #transforms wealth into utility
    uLLDyn[i,c,t]    = (pow(wLLp[i,c,t],oneminEtaDyn[i,c]) - 1) / oneminEtaDyn[i,c]        #transforms wealth into utility
    uRUDyn[i,c,t]    = (pow(wRUp[i,c,t],oneminEtaDyn[i,c]) - 1) / oneminEtaDyn[i,c]        #transforms wealth into utility
    uRLDyn[i,c,t]    = (pow(wRLp[i,c,t],oneminEtaDyn[i,c]) - 1) / oneminEtaDyn[i,c]        #transforms wealth into utility
    duLUDyn[i,c,t]   = uLUDyn[i,c,t] - uDyn[i,c,t]                                              #delta utility of wealth outcome Left Upper
    duLLDyn[i,c,t]   = uLLDyn[i,c,t] - uDyn[i,c,t]                                              #delta utility of wealth outcome Left Lower
    duRUDyn[i,c,t]   = uRUDyn[i,c,t] - uDyn[i,c,t]                                              #delta utility of wealth outcome Right Upper
    duRLDyn[i,c,t]   = uRLDyn[i,c,t] - uDyn[i,c,t]                                              #delta utility of wealth outcome right Lower
    eduLDyn[i,c,t]   = (duLUDyn[i,c,t] + duLLDyn[i,c,t]) / 2                                 #expected change in utility for Left gamble
    eduRDyn[i,c,t]   = (duRUDyn[i,c,t] + duRLDyn[i,c,t]) / 2                                 #expected change in utility for Right gamble
    deuDyn[i,c,t]    = eduLDyn[i,c,t] - eduRDyn[i,c,t]                                       #computes difference in expected change in utility
    sdeuDyn[i,c,t]   = -1 * betaDyn[i,c] * deuDyn[i,c,t]                                     #scaled by sensitivity parameter
    cpDyn[i,c,t]     = 1 / (1 + (exp(sdeuDyn[i,c,t])))                                       #choice probability
    theta[i,c,t,2]   = max( 0.000001 , min(0.999999 , cpDyn[i,c,t]) )                           #ensure 0 < cp < 1
    theta[i,c,t,4]   = max( 0.000001 , min(0.999999 , cpDyn[i,c,t]) )                           #ensure 0 < cp < 1
    theta[i,c,t,6]   = max( 0.000001 , min(0.999999 , cpDyn[i,c,t]) )                           #ensure 0 < cp < 1
    theta[i,c,t,8]   = max( 0.000001 , min(0.999999 , cpDyn[i,c,t]) )                           #ensure 0 < cp < 1







#Choice
    y[i,c,t]      ~ dbern(theta[i,c,t,z[i]])                                                 #bernoulli distributed choice
}# end of trials
}# end of conditions
}# end of subjects

##PRIORS

#indicator variables
#the model indicator variable z can take on any value from 1:n, and is subject to two stochastic processes, to prevent getting stuck
#the n values map onto just 2 models, and is simply a means of obtaining parameter expansion for the model indication

for (i in 1:nSubjects){
px_z1[i]    ~ dcat(pz[])                                 #parameter expansion variable for z, takes on integers 1:n with equal probability
px_z2[i]    ~ dcat(pz[])                                 #parameter expansion variable for z, takes on integers 1:n with equal probability
delta_z1[i] = px_z2[i]-1                                 #parameter expansion variable for z, takes on integers 0:n-1 with equal probability
sum_z[i]    = px_z1[i]+delta_z1[i]                       #sum takes on integers 1:2*n -1 with equal probability
z[i]        = (sum_z[i] - (8 * trunc(sum_z[i]/8))) + 1   #modulo n, adding 1 to return to values 1 to 8
}# end of subjects

#submodels
for (i in 1:nSubjects){
for (c in 1:nConditions){

  #Dynamic independent
  betaNoDyn[i,c]        = exp(log_betaNoDyn[i,c])                           #lognormally distributed prior
  log_betaNoDyn[i,c]    ~ dnorm(mu_log_betaNoDyn[c], tau_log_betaNoDyn[c])  #log beta sampled from normal hyperprior

  #Dynamic dependent
  betaDyn[i,c]        = exp(log_betaDyn[i,c])                               #lognormally distributed prior
  log_betaDyn[i,c]    ~ dnorm(mu_log_betaDyn[c], tau_log_betaDyn[c])        #log beta sampled from normal hyperprior

}#end of conditions

#Dynamic independent
etaNoDyn[i]         ~ dnorm(mu_etaNoDyn,tau_etaNoDyn)                       #normal distributed, free to vary across participants, fixed across conditions

#Dynamic dependent
etaDyn[i]          ~ dnorm(mu_etaDyn,tau_etaDyn)                            #common eta part, normal distributed, free to vary across participants, fixed across conditions
delta_eta[i,1] = 0                                                      #delta eta additive, always 0
delta_eta_tmp[i,2] ~ dnorm(mu_delta_etaDyn,tau_delta_etaDyn)                #delta eta multiplicative, free to vary across participants
delta_eta[i,2]     = ifelse(delta_eta_tmp[i,2] > 0, delta_eta_tmp[i,2], 0)          #Fix model to only allow positive change from additive to multiplicative

}# end of subjects


##HYPERPRIORS

for (c in 1:nConditions){

#Dynamic independent
mu_log_betaNoDyn[c]       ~ dunif(muLogBetaL,muLogBetaU)
tau_log_betaNoDyn[c]      = pow(sigma_log_betaNoDyn[c],-2)
sigma_log_betaNoDyn[c]    ~ dunif(sigmaLogBetaL,sigmaLogBetaU)

#Dynamic dependent
mu_log_betaDyn[c]         ~ dunif(muLogBetaL,muLogBetaU)
tau_log_betaDyn[c]        = pow(sigma_log_betaDyn[c],-2)
sigma_log_betaDyn[c]      ~ dunif(sigmaLogBetaL,sigmaLogBetaU)


}# end of conditions

mu_etaNoDyn            ~ dunif(muEtaL,muEtaU)
tau_etaNoDyn          = pow(sigma_etaNoDyn,-2)
sigma_etaNoDyn        ~ dunif(sigmaEtaL,sigmaEtaU)

mu_etaDyn             ~ dunif(muEtaL,muEtaU)
tau_etaDyn            = pow(sigma_etaDyn,-2)
sigma_etaDyn          ~ dunif(sigmaEtaL,sigmaEtaU)

mu_delta_etaDyn    ~ dunif(muDeltaEtaL,muDeltaEtaU)
tau_delta_etaDyn   = pow(sigma_delta_etaDyn,-2)
sigma_delta_etaDyn ~ dunif(sigmaDeltaEtaL,sigmaDeltaEtaU)


}